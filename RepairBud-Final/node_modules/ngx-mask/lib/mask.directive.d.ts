import { ControlValueAccessor, FormControl, ValidationErrors } from '@angular/forms';
import { OnChanges, SimpleChanges } from '@angular/core';
import { CustomKeyboardEvent } from './custom-keyboard-event';
import { IConfig } from './config';
import { MaskService } from './mask.service';
import * as ɵngcc0 from '@angular/core';
export declare class MaskDirective implements ControlValueAccessor, OnChanges {
    private document;
    private _maskService;
    protected _config: IConfig;
    maskExpression: string;
    specialCharacters: IConfig['specialCharacters'];
    patterns: IConfig['patterns'];
    prefix: IConfig['prefix'];
    suffix: IConfig['suffix'];
    thousandSeparator: IConfig['thousandSeparator'];
    decimalMarker: IConfig['decimalMarker'];
    dropSpecialCharacters: IConfig['dropSpecialCharacters'] | null;
    hiddenInput: IConfig['hiddenInput'] | null;
    showMaskTyped: IConfig['showMaskTyped'] | null;
    placeHolderCharacter: IConfig['placeHolderCharacter'] | null;
    shownMaskExpression: IConfig['shownMaskExpression'] | null;
    showTemplate: IConfig['showTemplate'] | null;
    clearIfNotMatch: IConfig['clearIfNotMatch'] | null;
    validation: IConfig['validation'] | null;
    separatorLimit: IConfig['separatorLimit'] | null;
    allowNegativeNumbers: IConfig['allowNegativeNumbers'] | null;
    private _maskValue;
    private _inputValue;
    private _position;
    private _start;
    private _end;
    private _code;
    constructor(document: any, _maskService: MaskService, _config: IConfig);
    onChange: (_: any) => void;
    onTouch: () => void;
    ngOnChanges(changes: SimpleChanges): void;
    validate({ value }: FormControl): ValidationErrors | null;
    onInput(e: CustomKeyboardEvent): void;
    onBlur(): void;
    onFocus(e: MouseEvent | CustomKeyboardEvent): void;
    onKeyDown(e: CustomKeyboardEvent): void;
    /** It writes the value in the input */
    writeValue(inputValue: string | number): Promise<void>;
    registerOnChange(fn: any): void;
    registerOnTouched(fn: any): void;
    suffixCheckOnPressDelete(keyCode: number, el: HTMLInputElement): void;
    /** It disables the input element */
    setDisabledState(isDisabled: boolean): void;
    onModelChange(e: any): void;
    private _repeatPatternSymbols;
    private _applyMask;
    private _validateTime;
    private _getActualInputLength;
    private _createValidationError;
    static ɵfac: ɵngcc0.ɵɵFactoryDef<MaskDirective, never>;
    static ɵdir: ɵngcc0.ɵɵDirectiveDefWithMeta<MaskDirective, "[mask]", never, { "maskExpression": "mask"; "specialCharacters": "specialCharacters"; "patterns": "patterns"; "prefix": "prefix"; "suffix": "suffix"; "thousandSeparator": "thousandSeparator"; "decimalMarker": "decimalMarker"; "dropSpecialCharacters": "dropSpecialCharacters"; "hiddenInput": "hiddenInput"; "showMaskTyped": "showMaskTyped"; "placeHolderCharacter": "placeHolderCharacter"; "shownMaskExpression": "shownMaskExpression"; "showTemplate": "showTemplate"; "clearIfNotMatch": "clearIfNotMatch"; "validation": "validation"; "separatorLimit": "separatorLimit"; "allowNegativeNumbers": "allowNegativeNumbers"; }, {}, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFzay5kaXJlY3RpdmUuZC50cyIsInNvdXJjZXMiOlsibWFzay5kaXJlY3RpdmUuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBGb3JtQ29udHJvbCwgVmFsaWRhdGlvbkVycm9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcyB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQ3VzdG9tS2V5Ym9hcmRFdmVudCB9IGZyb20gJy4vY3VzdG9tLWtleWJvYXJkLWV2ZW50JztcbmltcG9ydCB7IElDb25maWcgfSBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBNYXNrU2VydmljZSB9IGZyb20gJy4vbWFzay5zZXJ2aWNlJztcbmV4cG9ydCBkZWNsYXJlIGNsYXNzIE1hc2tEaXJlY3RpdmUgaW1wbGVtZW50cyBDb250cm9sVmFsdWVBY2Nlc3NvciwgT25DaGFuZ2VzIHtcbiAgICBwcml2YXRlIGRvY3VtZW50O1xuICAgIHByaXZhdGUgX21hc2tTZXJ2aWNlO1xuICAgIHByb3RlY3RlZCBfY29uZmlnOiBJQ29uZmlnO1xuICAgIG1hc2tFeHByZXNzaW9uOiBzdHJpbmc7XG4gICAgc3BlY2lhbENoYXJhY3RlcnM6IElDb25maWdbJ3NwZWNpYWxDaGFyYWN0ZXJzJ107XG4gICAgcGF0dGVybnM6IElDb25maWdbJ3BhdHRlcm5zJ107XG4gICAgcHJlZml4OiBJQ29uZmlnWydwcmVmaXgnXTtcbiAgICBzdWZmaXg6IElDb25maWdbJ3N1ZmZpeCddO1xuICAgIHRob3VzYW5kU2VwYXJhdG9yOiBJQ29uZmlnWyd0aG91c2FuZFNlcGFyYXRvciddO1xuICAgIGRlY2ltYWxNYXJrZXI6IElDb25maWdbJ2RlY2ltYWxNYXJrZXInXTtcbiAgICBkcm9wU3BlY2lhbENoYXJhY3RlcnM6IElDb25maWdbJ2Ryb3BTcGVjaWFsQ2hhcmFjdGVycyddIHwgbnVsbDtcbiAgICBoaWRkZW5JbnB1dDogSUNvbmZpZ1snaGlkZGVuSW5wdXQnXSB8IG51bGw7XG4gICAgc2hvd01hc2tUeXBlZDogSUNvbmZpZ1snc2hvd01hc2tUeXBlZCddIHwgbnVsbDtcbiAgICBwbGFjZUhvbGRlckNoYXJhY3RlcjogSUNvbmZpZ1sncGxhY2VIb2xkZXJDaGFyYWN0ZXInXSB8IG51bGw7XG4gICAgc2hvd25NYXNrRXhwcmVzc2lvbjogSUNvbmZpZ1snc2hvd25NYXNrRXhwcmVzc2lvbiddIHwgbnVsbDtcbiAgICBzaG93VGVtcGxhdGU6IElDb25maWdbJ3Nob3dUZW1wbGF0ZSddIHwgbnVsbDtcbiAgICBjbGVhcklmTm90TWF0Y2g6IElDb25maWdbJ2NsZWFySWZOb3RNYXRjaCddIHwgbnVsbDtcbiAgICB2YWxpZGF0aW9uOiBJQ29uZmlnWyd2YWxpZGF0aW9uJ10gfCBudWxsO1xuICAgIHNlcGFyYXRvckxpbWl0OiBJQ29uZmlnWydzZXBhcmF0b3JMaW1pdCddIHwgbnVsbDtcbiAgICBhbGxvd05lZ2F0aXZlTnVtYmVyczogSUNvbmZpZ1snYWxsb3dOZWdhdGl2ZU51bWJlcnMnXSB8IG51bGw7XG4gICAgcHJpdmF0ZSBfbWFza1ZhbHVlO1xuICAgIHByaXZhdGUgX2lucHV0VmFsdWU7XG4gICAgcHJpdmF0ZSBfcG9zaXRpb247XG4gICAgcHJpdmF0ZSBfc3RhcnQ7XG4gICAgcHJpdmF0ZSBfZW5kO1xuICAgIHByaXZhdGUgX2NvZGU7XG4gICAgY29uc3RydWN0b3IoZG9jdW1lbnQ6IGFueSwgX21hc2tTZXJ2aWNlOiBNYXNrU2VydmljZSwgX2NvbmZpZzogSUNvbmZpZyk7XG4gICAgb25DaGFuZ2U6IChfOiBhbnkpID0+IHZvaWQ7XG4gICAgb25Ub3VjaDogKCkgPT4gdm9pZDtcbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZDtcbiAgICB2YWxpZGF0ZSh7IHZhbHVlIH06IEZvcm1Db250cm9sKTogVmFsaWRhdGlvbkVycm9ycyB8IG51bGw7XG4gICAgb25JbnB1dChlOiBDdXN0b21LZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICBvbkJsdXIoKTogdm9pZDtcbiAgICBvbkZvY3VzKGU6IE1vdXNlRXZlbnQgfCBDdXN0b21LZXlib2FyZEV2ZW50KTogdm9pZDtcbiAgICBvbktleURvd24oZTogQ3VzdG9tS2V5Ym9hcmRFdmVudCk6IHZvaWQ7XG4gICAgLyoqIEl0IHdyaXRlcyB0aGUgdmFsdWUgaW4gdGhlIGlucHV0ICovXG4gICAgd3JpdGVWYWx1ZShpbnB1dFZhbHVlOiBzdHJpbmcgfCBudW1iZXIpOiBQcm9taXNlPHZvaWQ+O1xuICAgIHJlZ2lzdGVyT25DaGFuZ2UoZm46IGFueSk6IHZvaWQ7XG4gICAgcmVnaXN0ZXJPblRvdWNoZWQoZm46IGFueSk6IHZvaWQ7XG4gICAgc3VmZml4Q2hlY2tPblByZXNzRGVsZXRlKGtleUNvZGU6IG51bWJlciwgZWw6IEhUTUxJbnB1dEVsZW1lbnQpOiB2b2lkO1xuICAgIC8qKiBJdCBkaXNhYmxlcyB0aGUgaW5wdXQgZWxlbWVudCAqL1xuICAgIHNldERpc2FibGVkU3RhdGUoaXNEaXNhYmxlZDogYm9vbGVhbik6IHZvaWQ7XG4gICAgb25Nb2RlbENoYW5nZShlOiBhbnkpOiB2b2lkO1xuICAgIHByaXZhdGUgX3JlcGVhdFBhdHRlcm5TeW1ib2xzO1xuICAgIHByaXZhdGUgX2FwcGx5TWFzaztcbiAgICBwcml2YXRlIF92YWxpZGF0ZVRpbWU7XG4gICAgcHJpdmF0ZSBfZ2V0QWN0dWFsSW5wdXRMZW5ndGg7XG4gICAgcHJpdmF0ZSBfY3JlYXRlVmFsaWRhdGlvbkVycm9yO1xufVxuIl19